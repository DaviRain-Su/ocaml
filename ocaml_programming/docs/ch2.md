# 2.2.3.1.手动创建沙丘项目

创建一个dune的文件 `dune`，并在其中添加以下内容：

```dune
(executable
 (name hello))
```

它声明了一个可执行文件（可以执行的程序），其主文件是 hello.ml 。

另外创建一个名为 dune-project 的文件，并将以下内容放入其中：

```dune
(lang dune 3.14)
```

您想要使用 Dune 编译的每个源代码树的根目录中都需要此项目文件。一般来说，源树的每个子目录中都会有一个 dune 文件，但根目录下只有一个 dune-project 文件。

现在，您可以在项目的根目录中创建一个名为 hello.ml 的文件，并将以下内容放入其中：

```ocaml
let () = print_endline "Hello, world!"
```

然后终端运行

```shell
dune build hello.exe
```

请注意， .exe 扩展名在 Dune 的所有平台上使用，而不仅仅是在 Windows 上。这会导致 Dune 构建本机可执行文件而不是字节码可执行文件。

Dune 将创建一个目录 _build 并在其中编译我们的程序。这是构建系统相对于直接运行编译器的好处之一：它们不会用一堆生成的文件污染源目录，而是在单独的目录中干净地创建它们。 _build 内部有许多由 Dune 创建的文件。我们的可执行文件被埋藏在下面几层：

```shell
_build/default/hello.exe
Hello, world!
```

也可以直接运行

```shell
dune exec ./hello.exe
Hello world!
```

清理🧹代码

```shell
dune clean
```

这将删除 _build 目录，只留下源代码。

> 不要编辑 _build 目录中的任何文件。如果您在尝试保存只读文件时遇到错误，则您可能正在尝试编辑 _build 目录中的文件。

## 2.2.3.2.自动创建沙丘项目

Dune 还可以为您创建项目。在项目的根目录中运行以下命令：

```shell
$ dune init project calculator
$ cd calculator
$ code .
```

这将创建一个名为 calculator 的目录，其中包含一个名为 dune-project 的文件和一个名为 dune 的文件。这两个文件的内容与我们在上一节中手动创建的内容相同。

```shell
$ dune exec bin/main.exe
```

它将打印 Hello, World!

## 2.2.3.3.连续运行沙丘

Dune 还可以在后台运行以监视源文件的更改并自动重新构建项目。在项目的根目录中运行以下命令：

```shell
$ dune build --watch
```

Dune 将响应它正在等待文件系统更改。

## 2.3.1.基本类型和值

OCaml 不会自动在 int 和 float 之间进行转换。如果您想进行转换，有两个内置函数可用于此目的： int_of_float 和 float_of_int 。

```ocaml
let x = 3.14 in
let y = int_of_float x in
let z = float_of_int 42 in
```

您可以使用 char_of_int 和 int_of_char 将字符与整数相互转换。

```ocaml
let x = char_of_int 65 in
let y = int_of_char 'A' in
```


对于三种基本类型，有内置函数： string_of_int 、 string_of_float 、 string_of_bool

```ocaml
let x = string_of_int 42 in
let y = string_of_float 3.14 in
let z = string_of_bool true in
```

对于相同的三种基本类型，如果可能的话，有内置函数可以从字符串进行转换： int_of_string 、 float_of_string 和 bool_of_string 。

```ocaml
let x = int_of_string "42" in
let y = float_of_string "3.14" in
let z = bool_of_string "true" in
```

没有 char_of_string ，但可以通过基于 0 的索引来访问字符串的各个字符。索引运算符用点和方括号编写

```ocaml
let x = "hello".[1];;
```

##  2.3.2.更多运算符

OCaml 中有两个相等运算符 = 和 == ，以及相应的不等运算符 <> 和 != 。运算符 = 和 <> 检查结构相等性，而 == 和 != 检查物理相等性。

在我们研究 OCaml 的命令式功能之前，它们之间的差异很难解释。如果您现在好奇，请参阅 Stdlib.(==) 的文档。

## 2.3.3.断言

表达式 assert e 计算 e 。如果结果是 true ，则不会再发生任何事情，并且整个表达式的计算结果为一个称为单位的特殊值。单位值写作 () ，其类型为 unit 。但如果结果是 false ，则会引发异常。

```ocaml
let x = 42 in
assert (x = 42);
assert (x = 43); (* raises an exception *)
```

## 2.3.4.if表达式


无论您是编写单个 if 表达式还是高度嵌套的 if 表达式，您都应该将最终的 else 视为强制性的。如果省略它，您可能会收到一条目前难以理解的错误消息。

```ocaml
if e1 then e2 else e3
```

静态语义。 if 表达式的静态语义：

- 如果 e1 具有类型 bool 且 e2 具有类型 t 且 e3 具有类型 t 那么 if e1 then e2 else e3 的类型为 t

我们是否调用函数的参数 x 还是  y 本质上并不重要；不管怎样，它仍然是平方函数。因此，在程序中，这两个函数应该是相同的：

```ocaml
let f x = x * x
let f y = y * y
```

alpha 等价：两个函数在变量重命名之前是等价的

有一个术语通常用于描述这种现象：变量的新绑定会隐藏变量名称的任何旧绑定。打个比方，就好像新绑定暂时在旧绑定上投下了阴影。但最终，随着阴影消退，旧的绑定可能会重新出现。

总而言之，每个 let 定义都绑定一个全新的变量。如果新变量碰巧与旧变量同名，则新变量会暂时隐藏旧变量。但旧变量仍然存在，并且它的值是不可变的：它永远不会改变。因此，尽管 let 表达式表面上看起来像命令式语言中的赋值语句，但它们实际上是完全不同的。

## 2.4 函数

非递归函数的定义如下：

```ocaml
let f x = ...
```

递归函数的定义如下：

```ocaml
let rec f x = ...
```

区别只是 rec 关键字。明确必须添加关键字才能使函数递归可能有点令人惊讶，因为大多数语言默认情况下都假设它们是递归的。但 OCaml 并没有做出这样的假设。

```ocaml
(** [fact n] is [n!].
    Requires: [n >= 0]. *)
let rec fact n = if n = 0 then 1 else n * fact (n - 1)
```

函数上方提供了规范注释来记录函数的前置条件 ( Requires ) 和后置条件 ( is )。

当我们为 x 和 y 编写类型注释时，括号是必需的。我们通常会省略这些注释，因为让编译器推断它们更简单。有时您会想要显式地写下类型。
一个特别有用的时刻是当您从编译器中收到您不理解的类型错误时。显式注释类型可以帮助调试此类错误消息。

可以使用 and 关键字定义相互递归函数：

```
let rec f x1 ... xn = e1
and g y1 ... yn = e2
```

```ocaml
(** [even n] is whether [n] is even.
    Requires: [n >= 0]. *)
let rec even n =
  n = 0 || odd (n - 1)

(** [odd n] is whether [n] is odd.
    Requires: [n >= 0]. *)
and odd n =
  n <> 0 && even (n - 1);;
```

请注意递归函数的类型检查规则如何假设函数标识符 f 具有特定类型，然后检查函数体在该假设下是否类型正确。这是因为 f 位于函数体本身的范围内（就像参数位于范围内一样）。

这个概念确实有些复杂，让我来详细解释一下：

1. 递归函数的本质：
   递归函数是在其自身定义中调用自己的函数。这意味着函数体内部会引用到函数本身。

2. 类型检查的挑战：
   当编译器或类型检查器遇到递归函数时，它面临一个挑战：在检查函数体之前，它需要知道函数的类型，但函数的类型又依赖于其函数体。

3. 类型检查的策略：
   为了解决这个循环依赖，类型系统采用了一种特殊的策略：

   a. 假设：首先，它假设函数具有某个特定的类型。
   b. 验证：然后，在这个假设的基础上检查函数体。
   c. 一致性：如果函数体在这个假设下类型正确，那么这个假设就被证明是有效的。

4. 函数标识符的作用域：
   在这个过程中，函数的标识符（比如 f）被视为在函数体内是可见的，就像函数的参数一样。这允许函数体内部引用自身。

5. 具体例子：
   让我们看一个简单的递归函数例子（使用 OCaml 语法）：

   ```ocaml
   let rec factorial n =
     if n = 0 then 1
     else n * factorial (n - 1)
   ```

   类型检查过程：
   a. 假设 `factorial` 的类型是 `int -> int`
   b. 检查函数体：
      - `n` 被用作 `int`（与 0 比较，与 1 相乘）
      - `factorial` 被调用时传入 `int`（n - 1）
      - 返回值是 `int`
   c. 验证：函数体在假设 `factorial : int -> int` 的情况下类型正确
   d. 结论：假设成立，`factorial` 的类型确实是 `int -> int`

6. 为什么这很重要：
   这种方法允许类型系统正确地处理递归函数，即使在函数定义还未完全处理完时。它保证了类型安全，同时允许递归定义的灵活性。

7. 在其他语言中：
   这种方法在许多具有静态类型系统的函数式编程语言中都很常见，如 Haskell、ML 等。

总结：
这个规则本质上是说，类型检查器在检查递归函数时，会先对函数类型做一个"教育性的猜测"，然后验证这个猜测是否与函数体一致。这允许函数在自己的定义中引用自己，同时保持类型的一致性和正确性。

这个概念可能一开始有点抽象，但它是处理递归函数类型检查的关键机制。您对这个解释还有什么疑问吗？或者您想看更多的例子来加深理解？

## 2.4.2.匿名函数

匿名函数也称为 lambda 表达式，该术语来自 lambda 演算，它是一种计算的数学模型，与图灵机是计算模型的意义相同。在 lambda 演算中， fun x -> e 将写作。表示匿名函数。

动态语义。匿名函数已经是一个值。无需执行任何计算。

## 2.4.3. Function Application

e0 e1 e2 ... en

第一个表达式 e0 是函数，它应用于参数 e1 到 en 。请注意，参数周围不需要括号来指示函数应用程序，因为它们在 C 系列语言（包括 Java）中是这样的。


如果将这些求值规则与 let 表达式的规则进行比较，您会发现它们都涉及替换。这不是意外。事实上，程序中出现 let x = e1 in e2 的任何地方，我们都可以将其替换为 (fun x -> e2) e1 。它们在语法上不同，但在语义上等效。本质上， let 表达式只是匿名函数应用的语法糖。



这段描述解释了 OCaml（和许多其他函数式编程语言）中 `let` 表达式和函数应用之间的深层关系。让我来详细解释一下：

1. `let` 表达式的形式：
   ```ocaml
   let x = e1 in e2
   ```

2. 等价的函数应用形式：
   ```ocaml
   (fun x -> e2) e1
   ```

3. 语义等价性：
   这两种形式在语义上是等价的，意味着它们的行为和结果是相同的。

4. 替换规则：
   - 在 `let` 表达式中，`e2` 中的 `x` 被 `e1` 的值替换。
   - 在函数应用中，函数体（即 `e2`）中的参数 `x` 被参数值（即 `e1`）替换。

5. "语法糖"的概念：
   称 `let` 表达式为函数应用的"语法糖"，意味着它提供了一种更简洁、更易读的方式来表达相同的概念。

6. 实际例子：

   考虑以下 `let` 表达式：
   ```ocaml
   let x = 5 in x * 2
   ```

   这等价于以下函数应用：
   ```ocaml
   (fun x -> x * 2) 5
   ```

   两者都会计算出结果 10。

7. 为什么这很重要：
   - 理解这种等价性有助于深入理解语言的核心概念。
   - 它展示了函数和绑定之间的紧密关系。
   - 在某些情况下，可以根据需要在这两种形式之间转换。

8. 在其他上下文中的应用：
   这种理解也可以扩展到其他结构，例如：
   ```ocaml
   let f x = x + 1 in f 3
   ```
   可以看作是：
   ```ocaml
   (fun f -> f 3) (fun x -> x + 1)
   ```

9. 求值顺序：
   这种等价性也解释了为什么在 `let x = e1 in e2` 中，`e1` 总是在 `e2` 之前求值。

10. 局限性：
    虽然在大多数情况下这种等价性成立，但在某些特殊情况下（如涉及递归定义时），可能会有细微差别。

理解这种等价性有助于：
- 更深入地理解语言的工作原理
- 在需要时进行代码重构
- 理解更复杂的语言特性（如模式匹配）是如何建立在这些基本概念之上的

这个概念确实有点抽象，但它揭示了函数式编程语言的一些核心设计原则。您对这个解释还有什么疑问吗？或者您想看一些更复杂的例子来进一步理解这个概念？

##  2.4.4.管道

OCaml 中有一个内置的用于函数应用的中缀运算符，称为管道运算符，写为 |> 。想象一下，描绘一个指向右侧的三角形。比喻是值通过管道从左到右发送。例如，假设我们有上面的增量函数 inc 以及对其输入求平方的函数 square ：

```ocaml
let inc x = x + 1;;
let square x = x * x;;
```

```ocaml
square (inc 5);;
5 |> inc |> square;;
```

由于 e1 |> e2 只是 e2 e1 的另一种编写方式，因此我们不需要声明 |> 的语义：它与函数应用程序相同。这两个程序是语法上不同但语义上等效的表达式的另一个示例。

这段描述解释了OCaml中管道操作符 `|>` 的本质。让我详细解释一下：

1. 管道操作符 `|>` 的定义：
   `e1 |> e2` 等价于 `e2 e1`

2. 语法差异，语义等价：
   这两种写法在语法（how it's written）上不同，但在语义（what it means）上是完全相同的。

3. 函数应用的另一种表示：
   `|>` 本质上只是函数应用的另一种写法，不需要新的语义规则来解释它。

4. 实际例子：
   ```ocaml
   (* 使用管道操作符 *)
   5 |> (fun x -> x * 2)

   (* 等价的普通函数应用 *)
   (fun x -> x * 2) 5
   ```
   这两种写法都会得到结果 10。

5. 管道操作符的优势：
   - 提高可读性，特别是在多个函数连续应用时
   - 使代码按照数据流的顺序从左到右阅读
   - 减少括号的使用

6. 多个管道操作的例子：
   ```ocaml
   (* 使用管道操作符 *)
   5 |> (fun x -> x * 2) |> (fun x -> x + 3)

   (* 等价的嵌套函数应用 *)
   (fun x -> x + 3) ((fun x -> x * 2) 5)
   ```

7. 在实际编程中的应用：
   管道操作符特别适合处理数据转换流程，使代码更易读和理解：

   ```ocaml
   let result =
     [1; 2; 3; 4; 5]
     |> List.map (fun x -> x * 2)
     |> List.filter (fun x -> x > 5)
     |> List.fold_left (+) 0
   ```

   这比嵌套的函数调用更易读：

   ```ocaml
   let result =
     List.fold_left (+) 0
       (List.filter (fun x -> x > 5)
         (List.map (fun x -> x * 2) [1; 2; 3; 4; 5]))
   ```

8. 语言设计的洞察：
   这个特性展示了如何通过引入新的语法来改善代码的可读性，而不需要改变语言的核心语义。

9. 类似概念在其他语言中：
   - F# 也有类似的 `|>` 操作符
   - Elixir 使用 `|>` 作为管道操作符
   - Haskell 有类似功能的 `$` 操作符（虽然方向相反）

理解 `|>` 和普通函数应用的等价性有助于：
- 更灵活地组织和重构代码
- 理解函数式编程中数据流的概念
- 欣赏语言设计中语法糖的作用

这个特性是OCaml（和其他一些函数式语言）提高代码可读性和表达能力的好例子。您对这个解释还有什么疑问吗？或者您想看一些更复杂的使用管道操作符的例子？

## 2.4.5。多态函数 #

多态函数是可以接受多种类型的参数的函数。在OCaml中，多态函数可以通过类型变量来实现。例如，考虑以下函数：

```ocaml
let id x = x;;
```
val id : 'a -> 'a = <fun>

'a 是一个类型变量：它代表未知类型，就像常规变量代表未知值一样。类型变量始终以单引号开头。常用的类型变量包括 'a 、 'b 和 'c ，OCaml 程序员通常用希腊语发音：alpha、beta 和 gamma。

因为您可以将 id 应用于多种类型的值，所以它是一个多态函数：它可以应用于多种（多）形式（morph）。

通过手动类型注释，可以为多态函数提供比编译器自动推断的类型更具限制性的类型。

```ocaml
let id : 'a -> 'a = fun x -> x;;
let id_int : int -> int = id;;
```
